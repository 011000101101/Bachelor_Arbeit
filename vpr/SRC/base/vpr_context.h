#ifndef VPR_CONTEXT_H
#define VPR_CONTEXT_H
#include <unordered_map>
#include <memory>

#include "vtr_matrix.h"
#include "netlist.h"
#include "atom_netlist.h"
#include "rr_node.h"
#include "tatum/TimingGraph.hpp"
#include "tatum/TimingConstraints.hpp"
#include "power.h"
#include "power_components.h"

struct VprContext {
    /********************************************************************
     Atom Netlist
     ********************************************************************/
    /* Atom netlist */
    AtomNetlist atom_nl;

    /* Mappins to/from the Atom Netlist */
    AtomLookup atom_lookup;

    /* Atom net power info */
    std::unordered_map<AtomNetId,t_net_power> atom_net_power;

    /********************************************************************
     Timing
     ********************************************************************/
    std::shared_ptr<tatum::TimingGraph> timing_graph;
    std::shared_ptr<tatum::TimingConstraints> timing_constraints;

    t_timing_constraints* sdc; //TODO: remove classic SDC

    struct timing_analysis_profile_info {
        double timing_analysis_wallclock_time() {
            return sta_wallclock_time + slack_wallclock_time;
        }

        double old_timing_analysis_wallclock_time() {
            return old_sta_wallclock_time + old_delay_annotation_wallclock_time;
        }

        double sta_wallclock_time = 0.;
        double slack_wallclock_time = 0.;
        size_t num_full_updates = 0;

        double old_sta_wallclock_time = 0.;
        double old_delay_annotation_wallclock_time = 0.;
        size_t num_old_sta_full_updates = 0;
    };
    timing_analysis_profile_info timing_analysis_profile_stats;

    /********************************************************************
     CLB Netlist
     ********************************************************************/
    /* blocks in the clustered netlist */
    int num_blocks;
    struct s_block *blocks;

    /* External-to-complex blocks, post-packed netlist [NETS ONLY]*/
    t_netlist clbs_nlist;

    std::string placement_id; //SHA256 digest of .place file

    /********************************************************************
     Physical FPGA architecture 
     *********************************************************************/

    /* x and y dimensions of the FPGA itself, the core of the FPGA is from [1..nx][1..ny], the I/Os form a perimeter surrounding the core */
    int nx, ny;
    struct s_grid_tile **grid; /* FPGA complex blocks grid [0..nx+1][0..ny+1] */

    /* Special pointers to identify special blocks on an FPGA: I/Os, unused, and default */
    t_type_ptr IO_TYPE;
    t_type_ptr EMPTY_TYPE;
    t_type_ptr FILL_TYPE;

    /* block_types are blocks that can be moved by the placer
     such as: I/Os, CLBs, memories, multipliers, etc
     Different types of physical block are contained in type descriptors
     */
    int num_block_types;
    struct s_type_descriptor *block_types;

    /*******************************************************************
     Routing related
     ********************************************************************/

    /* chan_width is for x|y-directed channels; i.e. between rows */
    t_chan_width chan_width;

    /* [0..num_nets-1] of linked list start pointers.  Defines the routing.  */
    struct s_trace **trace_head, **trace_tail;

    std::string routing_id; //SHA256 digest of .route file

    /* Structures to define the routing architecture of the FPGA.           */
    int num_rr_nodes;
    t_rr_node *rr_nodes; /* [0..num_rr_nodes-1]          */

    int num_rr_indexed_data;
    t_rr_indexed_data *rr_indexed_data; /* [0 .. num_rr_indexed_data-1] */

    vtr::t_ivec ***rr_node_indices;


    t_rr_node_state* rr_node_state; /* [0..num_rr_nodes-1] */

    int **net_rr_terminals; /* [0..num_nets-1][0..num_pins-1] */

    int num_arch_switches;
    s_arch_switch_inf *arch_switch_inf; /* [0..(num_arch_switches-1)] */

    int num_rr_switches;
    s_rr_switch_inf *rr_switch_inf; /* autogenerated in build_rr_graph based on switch fan-in. [0..(num_rr_switches-1)] */
    /*
     * switch_fanin_remap is only used for printing out switch fanin stats (the -switch_stats option)
     * array index: [0..(num_arch_switches-1)]; 
     * map key: num of all possible fanin of that type of switch on chip
     * map value: remapped switch index (index in rr_switch_inf)
     */
    map<int, int> *switch_fanin_remap; 
    int **rr_blk_source; /* [0..num_blocks-1][0..num_class-1] */

    /* the head pointers of structures that are "freed" and used constantly */
    /*struct s_heap *heap_free_head;
    struct s_trace *trace_free_head;
    struct s_linked_f_pointer *linked_f_pointer_free_head;*/

    /*******************************************************************
     Timing related
     ********************************************************************/
    //TODO: Remove these max_internal_delay globals when the classic timing analyzer is removed
    float pb_max_internal_delay; /* biggest internal delay of block */
    const t_pb_type *pbtype_max_internal_delay; /* block type with highest internal delay */

    /*******************************************************************
     Power
     ********************************************************************/
    t_solution_inf solution_inf;
    t_power_output* power_output;
    t_power_commonly_used* power_commonly_used;
    t_power_tech* power_tech;
    t_power_arch* power_arch;
    t_net_power * clb_net_power;

    t_power_components power_by_component;

    /*******************************************************************
     Clock Network
     ********************************************************************/
    t_clock_arch * clock_arch;
};

#endif
